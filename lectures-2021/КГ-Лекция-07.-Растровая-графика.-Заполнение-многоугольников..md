# Алгоритм закраски (заполнения) по рёбрам
### Введем соглашение:

> Пиксель может иметь либо цвет фона, либо цвет закраски.

> Считаем, что эти 2 цвета дополняют друг друга (инвертируют).

> Для каждой сканирующей строки, пересекающей ребро многоугольника, дополнить(проинвертировать) все пиксели, расположенные правее точки пересечения.

> Задается цвет фона и цвет закраски; цвет закраски = !(цвет фона), цвет фона = !(цвет закраски) (инверсия/дополнение). 

В алгоритме заполнения по ребрам в отличие от предыдущего не требуется создавать и сортировать списки различных данных. Он очень прост:

![image](https://user-images.githubusercontent.com/62243773/166564927-5fe326d1-446a-4cc9-838f-2a7400d5bda0.png)

### Псевдокод алгоритма заполнения по ребрам
- Необходимо для каждой строки сканирования, пересекающей ребро многоугольника, ограничивающего закрашиваемую область, в точке с координатами `(X1, Y1)`
- Активизировать все пиксели, которые лежат справа от `(X1, Y1)` и для которых справедливо неравенство : `X + 1/2 > X1`.

К каждому ребру многоугольника алгоритм применяется индивидуально. Пересечения строк сканирования осуществляется аналогично алгоритму с [упорядоченным списком ребер](https://github.com/Mansurow/bmstu_CG/wiki/%D0%9A%D0%93-%D0%9B%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-06.-%D0%A0%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B2%D0%B0%D1%8F-%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D0%BA%D0%B0.-%D0%A0%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B2%D0%B0%D1%8F-%D1%80%D0%B0%D0%B7%D0%B2%D0%B5%D1%80%D1%82%D0%BA%D0%B0-%D1%81%D0%BF%D0%BB%D0%BE%D1%88%D0%BD%D1%8B%D1%85-%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D0%B5%D0%B9.), то есть определяются точки пересечений со сканирующими строками, проведенными через середины интервалов `(Y + 1/2)`. Рекомендуется использовать этот алгоритм совместно с дисплейным файлом, что позволяет выбирать и обрабатывать ребра в любом порядке. Ибо тогда при обработке ребра многоугольника обрабатываются пиксели из дисплейного файла, соответствующие точкам пересечения ребра со строкой сканирования.

После обработки всех ребер многоугольника, ограничивающего закрашиваемую область, дисплейный файл выводится в порядке сканирования на экран графического дисплея. 

> **Примечание:** Если брать не выпуклый многоугольник, то цвет каждого пикселя может изменяться многократно! Если пиксель изменяет свой цвет четное кол-во раз, то получим фоновый цвет. Если нечетное => цвет закраски.

### Пример обработки последовательно каждого ребра:

![image](https://user-images.githubusercontent.com/62243773/166565130-dc59f299-498b-413f-bb28-5930a530c2b3.png)

### Данный алгоритм характеризуется существенными недостатками: 
1. Оценка эффективности алгоритма (по времени)
   - Многократной обработкой одного и того же пикселя в случае областей закрашивания сложной формы(столько раз, сколько изменяем цвет пикселя);
   - Приходится обрабатывать не только те пиксели, которые находятся внутри многоугольника, но и пиксели за его пределами.
2. Зависимостью алгоритма от операций ввода/вывода.

> **Алгоритм крайне неэффективный!**

> **Кратко:** Ребра никак не упорядочиваются, сортировка не происходит. В этом алгоритме ребра могут обрабатываться в произвольном порядке. Алгоритм прост, но требует больших временных затрат, поскольку некоторые пиксели могут обрабатываться несколько раз.

Количество обработок пикселя определяется количеством ребер, расположенных левее этого пикселя.

# Алгоритм закраски (заполнения) с перегородкой

![image](https://user-images.githubusercontent.com/62243773/166565429-189e4406-b451-4d4d-bebc-947b03fda0dc.png)

Для сокращения числа обрабатываемых пикселей используется "перегородка".

**Перегородка** – воображаемая вертикальная прямая, которую мы проводим с целью уменьшения количества раз изменения цвета каждого пикселя.

В этом случае алгоритм модифицируется следующим образом: анализируется каждая точка пересечения каждого ребра многоугольника со строкой сканирования. Эффективность повышается за счет введения перегородки. Если текущая точка пересечения находится слева от перегородки, то активизируются все пиксели, центры которых лежат справа от точки пересечения ребра со строкой сканирования и слева от перегородки. Если же точка пересечения находится справа от перегородки, то активизируются пиксели, центры которых расположены слева или на пересечении строки сканирования с ребром многоугольника и справа от перегородки. Рекомендуется проводить перегородку через одну из вершин многоугольника и реализовывать данный алгоритм совместно с использованием дисплейного файла. 

### Для заполнения многоугольника руководствуемся правилом:
> Дополнить цвет пикселей, расположенных правее точки пересечения сканирующей строки с ребром многоугольника, но левее перегородки, если пересечение расположено левее перегородки.

### Псевдокод алгоритма заполнения с перегородкой
- Для каждой сканирующей строки, пересекающей ребро многоугольника:
  - Если пересечения находится слева от перегородки, то дополнить (проинвентировать) все пикселы, центры которых лежат справа от пересечения сканирующей строки с ребром и слева от перегородки.
  - Если пересечение находится справа от перегородки, то дополнить все пикселы, центры которых расположены слева или на пересечении сканирующей строки с ребром и справа от перегородки.

### Недостатки:
- Алгоритма заполнения с перегородкой все же остается неоднократная обработка части пикселей.

# Алгоритм со списком ребер и флагом
Для того, чтобы избавиться от этого, разработан модифицированный алгоритм заполнения сплошной области со списком ребер и флагом. Алгоритм со списком ребер и флагом - двух-шаговый алгоритм: 
- Во-первых, обрисовывается контур, ограничивающий область, в результате чего на каждой строке сканирования определяются пары ограничивающих пикселей - т.е. **очерчивание границ многоугольника**;
- Во-вторых, активизируются пиксели, расположенные между вычисленными на предыдущем шаге ограничивающими пикселями - т.е. **заполнения многоугольника**.

Вводится в рассмотрение еще и флаг - признак расположения очередного пикселя внутри или вне многоугольника. 
- Флаг = истина, если пиксель расположен внутри многоугольника;
- Флаг = ложь, если пиксель расположен вне многоугольника.

### Псевдокод алгоритма со списком ребер и флагом
```
1. Обрисовка контура:
   Используя соглашения о середине интервала между 
   сканирующими строками для каждого ребра, пересекающего сканирующую строку, 
   отметить самый левый пиксел, центр которого лежит справа от пересечения, 
   т.е. X + 1/2 > X_пересечения.
2. Заполнение:
  Для каждого сканирующей строки, пересекающей многоугольник (Цикл от Ymax до Ymin)
  2.1) f = 0, если пиксель находится вне области
              (f - промежуточная переменная, 
              показывающая расположение очередного пиксела: 
              fl=0 - пиксел лежит вне области заполнения, 
              fl=1 - пиксел лежит внутри заполняемой области);
  2.2) X = Xl (Xl - левая граница)
  2.3) пока (X <= Xr) (Xr - правая граница) выполнить следующие действия:
       Если пиксель (цвет) (X, Y) = граничному значению (цвету), тогда инвертировать флаг
            (f = 1, если было f = 0)
            (f = 0, если было f = 1)
       Если f = 1, тогда присвоить пикселю (X, Y) цвет многоугольника
       Иначе присвоить пикселю (X, Y) цвет фона
       X = X + 1
  Y = Y + 1
```

При реализации данного алгоритма каждый пиксель обрабатывается только один раз, следовательно временные затраты на выполнение операций ввода/вывода значительно меньше, чем в простом алгоритме заполнения по ребрам или в алгоритме с перегородкой. Существует аппаратная реализация алгоритма со списком ребер и флагом, в этом случае его скорость выполнения увеличивается на несколько порядков по сравнению с упорядоченным списком ребер (при программной реализации скорость выполнения алгоритмов отличается незначительно, в чем предлагается убедиться при выполнении лабораторной работы).

### Возникающие проблемы:

![image](https://user-images.githubusercontent.com/62243773/166573212-577ee29b-4cc0-4fec-8be5-c1e1bd126edf.png)

На стадии отрисовки границ, два ребра могут сливаться в одно. Как вариант – отрисовывать границу с использованием инверсного цвета пера. Либо же, первое ребро отрисовывается, при отрисовке последующих – если точку надо поставить в ту точку, которая уже подсвечена, то поставить её рядом.

![image](https://user-images.githubusercontent.com/62243773/166573231-5a67060a-45c8-4f54-a96f-6a6e05ce1482.png)

Также извечный вопрос строки, проходящей через вершины.
Также, использовать обычный способ отрисовки отрезков нельзя – может возникнуть разбиение; точек пересечения со сканирующей строкой может оказаться несколько.
